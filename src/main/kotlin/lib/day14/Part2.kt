package io.cloudtamer.adventofcode.lib.day14

fun getMaximumFuelOutput(availableTransforms: Map<Symbol, SymbolTransform>, oreBudget: Long): Long {
    val typicalOreAndWaste = getOresRequiredToMakeFuelWithWaste(availableTransforms)
    var leftoverWaste = typicalOreAndWaste.waste
    var remainingBudget = oreBudget
    var fuelProduced = 0L

    while (true) {
        // Get the base number of fuels that can be produced with the budget without using the waste
        val fuelsTossingWaste = remainingBudget / typicalOreAndWaste.expendedOre
        // Get the amount of waste generated by making all this fuel
        val totalAccruedWaste = typicalOreAndWaste.waste.mapValues { it.value * fuelsTossingWaste + leftoverWaste.getOrDefault(it.key, 0L) }
        // Turn waste back into ore
        val reducedAccruedWaste = reduceWaste(availableTransforms, totalAccruedWaste)
        // Determine how much we really spent by re-using waste
        val amountSpent = (fuelsTossingWaste * typicalOreAndWaste.expendedOre) - reducedAccruedWaste.getOrDefault("ORE", 0)

        // If we couldn't spend anything, we're out of budget
        if (amountSpent == 0L) break

        // Take the amount spent out of the budget and update fuel produced and leftover waste
        remainingBudget -= amountSpent
        fuelProduced += fuelsTossingWaste
        leftoverWaste = reducedAccruedWaste - "ORE"
    }

    return fuelProduced
}
